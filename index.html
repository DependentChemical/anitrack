<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Anime Watch Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
	<link rel="icon" type="image/png" href="favicon-192.png">
	
	<link rel="manifest" href="https://dependentchemical.github.io/anitrack/manifest.json">
	<script>
	  if ('serviceWorker' in navigator) {
		window.addEventListener('load', () => {
		  // The scope here should generally match your start_url/scope in the manifest
		  navigator.serviceWorker.register('https://dependentchemical.github.io/anitrack/sw.js', { scope: 'https://dependentchemical.github.io/anitrack/' })
			.then(registration => {
			  console.log('Service Worker registered: ', registration);
			})
			.catch(error => {
			  console.log('Service Worker registration failed: ', error);
			});
		});
	  }
	</script>
	
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Set default font to Inter for a modern look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            min-height: 10vh;
        }
        /* Custom scrollbar for a dark theme */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #111827; /* Tailwind gray-900 */
        }
        ::-webkit-scrollbar-thumb {
            background: #ea580c; /* Tailwind orange-700 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #f97316; /* Tailwind orange-600 */
        }
        /* Hide total_episodes input arrows */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }

        /* Define pulse animation for highlight */
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
        .animate-pulse {
          animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Long Press Visual Feedback Bar */
        .long-press-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 5px; /* Thicker bar for visibility */
            width: 0%;
            background-color: #f97316; /* primary-orange */
            opacity: 0;
            /* Match card border radius */
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
            z-index: 10;
        }
        
        /* Replacement highlight animation for search -> tracked card swap */
        @keyframes replaceHighlight {
            0% { transform: scale(0.98); box-shadow: 0 0 0 rgba(249,115,22,0); }
            30% { transform: scale(1.03); box-shadow: 0 8px 24px rgba(249,115,22,0.18); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(249,115,22,0); }
        }
        .replace-highlight {
            animation: replaceHighlight 700ms cubic-bezier(0.2, 0.8, 0.2, 1);
            will-change: transform, box-shadow;
        }
        /* Card action menu styles */
        .card-action-wrapper { position: relative; }
        .card-action-button { background: transparent; border: none; color: #9ca3af; padding: 6px; border-radius: 6px; }
        .card-action-button:hover { color: #f97316; background: rgba(249,115,22,0.06); }
        .card-action-menu { position: absolute; right: 0; top: 2.25rem; background: #111827; border: 1px solid rgba(249,115,22,0.12); padding: 6px; border-radius: 8px; min-width: 140px; box-shadow: 0 6px 18px rgba(0,0,0,0.6); z-index: 40; }
        .card-action-menu button { display: block; width: 100%; text-align: left; background: transparent; border: none; color: #f3f4f6; padding: 8px 10px; border-radius: 6px; }
        .card-action-menu button:hover { background: rgba(255,255,255,0.03); color: #ffedd5; }
        .card-action-menu.hidden { display: none; }
    /* slide/opacity animation for opening the menu */
    .card-action-menu { opacity: 0; transform: translateY(-6px); transition: opacity 180ms cubic-bezier(0.2,0.8,0.2,1), transform 180ms cubic-bezier(0.2,0.8,0.2,1); }
    .card-action-menu.visible { opacity: 1; transform: translateY(0); }
    /* emphasize delete option - red background with white text/icon */
    .card-action-menu .delete-option { background: #dc2626; color: #ffffff; display: block; padding: 8px 10px; border-radius: 6px; }
    .card-action-menu .delete-option span { color: #ffffff; }
    .card-action-menu .delete-option:hover { background: #b91c1c; color: #ffffff; }
        
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-orange': '#f97316', /* orange-600 */
                        'primary-dark': '#111827',   /* gray-900 */
                        'secondary-dark': '#1f2937', /* gray-800 */
                        'light-text': '#f3f4f6',     /* gray-100 */
                        'muted-text': '#9ca3af',     /* gray-400 */
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-primary-dark text-light-text antialiased">

    <div id="app" class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
        
        <section id="top-bar-container" class="flex flex-col md:flex-row items-start md:items-center mb-10 gap-4">
            
            <div id="user-info" 
                 class="flex items-center text-muted-text text-sm hover:text-light-text transition cursor-pointer mb-2 md:mb-0" 
                 onclick="showUserSelectModal()">
                <span data-lucide="user" class="w-5 h-5 mr-2 text-primary-orange"></span>
                <span id="current-username" class="font-semibold text-sm sm:text-base truncate">Loading User...</span>
                <span data-lucide="chevrons-up-down" class="w-4 h-4 ml-1 text-primary-orange"></span>
            </div>
            
            <div id="search-bar-wrapper" class="relative flex-grow w-full md:w-auto">
                <input type="text" id="search-input" placeholder="Search for an anime (e.g., Attack on Titan)..." 
                       class="w-full p-4 pl-12 sm:pl-16 rounded-xl bg-secondary-dark border border-primary-orange/30 focus:border-primary-orange focus:ring-1 focus:ring-primary-orange text-light-text transition duration-200 shadow-lg pr-12 sm:pr-16"
                       onkeyup="debouncedSearch()" 
                       oninput="toggleClearButton()">
                
                <span data-lucide="search" class="w-5 h-5 absolute left-4 sm:left-6 top-1/2 transform -translate-y-1/2 text-primary-orange"></span>
                
                <button id="clear-search-btn" onclick="clearSearch()"
                        class="absolute right-4 sm:right-6 top-1/2 transform -translate-y-1/2 text-primary-orange p-1 hover:text-orange-300 transition duration-150 hidden">
                    <span data-lucide="x-circle" class="w-5 h-5"></span>
                </button>
            </div>
        </section>
        
        <section class="mb-12">
            <div id="search-results" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                </div>
            
            <div id="search-message" class="text-center text-muted-text mt-8 hidden">
                Search for an anime to begin tracking!
            </div>
            <div id="loading-indicator" class="text-center text-primary-orange mt-8 hidden">
                <span data-lucide="loader-2" class="animate-spin inline-block w-8 h-8"></span> Loading...
            </div>
        </section>

        <section>
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-3xl font-bold flex items-center">
                    My List 
                    <span data-lucide="list-checks" class="w-6 h-6 ml-2 text-primary-orange"></span>
                </h2>
                <div class="flex items-center space-x-2">
                    <!-- Sort moved to the filter controls row -->
                </div>
            </div>
            
            <div id="filter-controls" class="flex flex-wrap gap-3 mb-6">
                </div>

            <div id="tracking-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                </div>
            <p id="empty-list-message" class="text-center text-muted-text mt-8 text-xl hidden">
                Your tracking list is empty. Search for an anime above to add it!
            </p>
        </section>
    </div>

    <div id="toast-message" class="fixed bottom-4 right-4 bg-primary-orange text-primary-dark p-3 rounded-lg shadow-2xl transition-opacity duration-300 opacity-0 hidden">
        Message goes here.
    </div>
    
    <div id="user-select-modal" class="fixed inset-0 bg-primary-dark bg-opacity-70 z-50 flex items-center justify-center hidden">
        <div class="bg-secondary-dark p-6 rounded-xl shadow-2xl max-w-sm w-full relative border border-primary-orange/50" onclick="event.stopPropagation()">
            <button onclick="hideModal('user-select-modal')" 
                    class="absolute top-3 right-3 text-muted-text hover:text-light-text transition">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>

            <h3 class="text-2xl font-bold mb-4 text-primary-orange">Switch/Manage Users</h3>
            
            <div id="user-list" class="max-h-60 overflow-y-auto pr-2 mb-4 space-y-2">
                </div>

            <hr class="border-gray-700 mb-4">
            
            <button id="add-new-user-btn" onclick="showRegisterModal()" 
                    class="w-full py-3 bg-primary-orange text-primary-dark font-bold rounded-lg transition duration-200 hover:bg-orange-500 shadow-md mb-2">
                <span data-lucide="plus" class="w-5 h-5 inline-block -mt-0.5 mr-2"></span> Create New User
            </button>
            
            <button id="data-transfer-btn" onclick="showDataTransferModal()" 
                    class="w-full py-3 bg-gray-600 text-light-text font-bold rounded-lg transition duration-200 hover:bg-gray-500 shadow-md">
                <span data-lucide="hard-drive" class="w-5 h-5 inline-block -mt-0.5 mr-2"></span> Data Transfer
            </button>
        </div>
    </div>
    
    <div id="login-modal" class="fixed inset-0 bg-primary-dark bg-opacity-70 z-50 flex items-center justify-center hidden">
        <form id="login-form" class="bg-secondary-dark p-6 rounded-xl shadow-2xl max-w-sm w-full relative border border-green-500/50" onsubmit="event.preventDefault(); loginUser()">
            <button type="button" onclick="hideModal('login-modal'); showUserSelectModal();" 
                    class="absolute top-3 right-3 text-muted-text hover:text-light-text transition">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>

            <h3 class="text-2xl font-bold mb-4 text-green-500">Login to User</h3>
            <p id="login-username" class="mb-4 text-light-text font-semibold"></p>
            
            <div class="mb-4">
                <label for="login-password" class="block text-sm font-medium text-light-text mb-1">Password</label>
                <input type="password" id="login-password" required
                       class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 focus:border-green-500 focus:ring-1 focus:ring-green-500 text-light-text">
            </div>
            
            <button type="submit" class="w-full py-3 bg-green-500 text-primary-dark font-bold rounded-lg transition duration-200 hover:bg-green-400 shadow-md">
                Unlock Data
            </button>
            <input type="hidden" id="login-user-id">
        </form>
    </div>

    <div id="register-modal" class="fixed inset-0 bg-primary-dark bg-opacity-70 z-50 flex items-center justify-center hidden">
        <form id="register-form" class="bg-secondary-dark p-6 rounded-xl shadow-2xl max-w-sm w-full relative border border-primary-orange/50" onsubmit="event.preventDefault(); handleNewUserRegistration()">
            <button type="button" onclick="hideModal('register-modal'); showUserSelectModal();" 
                    class="absolute top-3 right-3 text-muted-text hover:text-light-text transition">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>

            <h3 class="text-2xl font-bold mb-4 text-primary-orange">Register New User</h3>
            
            <div class="mb-4">
                <label for="register-username" class="block text-sm font-medium text-light-text mb-1">Username</label>
                <input type="text" id="register-username" required minlength="3"
                       class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 focus:border-primary-orange focus:ring-1 focus:ring-primary-orange text-light-text">
            </div>
            
            <div class="mb-6">
                <label for="register-password" class="block text-sm font-medium text-light-text mb-1">Password</label>
                <input type="password" id="register-password" required minlength="6"
                       class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 focus:border-primary-orange focus:ring-1 focus:ring-primary-orange text-light-text">
                <p class="text-xs text-muted-text mt-1">
                    This password is used to encrypt your list. Do not lose it!
                </p>
            </div>
            
            <button type="submit" class="w-full py-3 bg-primary-orange text-primary-dark font-bold rounded-lg transition duration-200 hover:bg-orange-500 shadow-md">
                Create & Switch
            </button>
        </form>
    </div>
    
    <div id="data-transfer-modal" class="fixed inset-0 bg-primary-dark bg-opacity-70 z-50 flex items-center justify-center hidden">
        <div class="bg-secondary-dark p-6 rounded-xl shadow-2xl max-w-sm w-full relative border border-primary-orange/50" onclick="event.stopPropagation()">
            <button onclick="hideModal('data-transfer-modal'); showUserSelectModal();" 
                    class="absolute top-3 right-3 text-muted-text hover:text-light-text transition">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>

            <h3 class="text-2xl font-bold mb-4 text-primary-orange">Data Transfer</h3>
            <p class="text-sm text-muted-text mb-6">
                Export or import a secure backup of the current user's data.
            </p>
            
            <div class="mb-6 p-4 border border-gray-700 rounded-lg">
                <h4 class="text-xl font-semibold mb-2 flex items-center">
                    <span data-lucide="download" class="w-5 h-5 mr-2 text-green-500"></span> Export Backup
                </h4>
                <p class="text-xs text-muted-text mb-3">
                    Creates a JSON file containing the encrypted list and user settings for the active user.
                </p>
                <button onclick="exportUserData()" 
                        class="w-full py-2 bg-green-500 text-primary-dark font-bold rounded-lg transition duration-200 hover:bg-green-400 shadow-md">
                    Download User Data
                </button>
            </div>
            
            <div class="p-4 border border-gray-700 rounded-lg">
                <h4 class="text-xl font-semibold mb-2 flex items-center">
                    <span data-lucide="upload" class="w-5 h-5 mr-2 text-primary-orange"></span> Import Backup
                </h4>
                <p class="text-xs text-muted-text mb-3">
                    Imports a user backup file. A **new user** will be created. You'll need the original password to log in.
                </p>
                <input type="file" id="import-file-input" accept=".json" class="hidden" onchange="handleImportFile(this.files[0])">
                <button onclick="document.getElementById('import-file-input').click()" 
                        class="w-full py-2 bg-primary-orange text-primary-dark font-bold rounded-lg transition duration-200 hover:bg-orange-500 shadow-md">
                    Choose Backup File
                </button>
            </div>
        </div>
    </div>

    <!-- Group selection modal -->
    <div id="group-selection-modal" class="fixed inset-0 bg-primary-dark bg-opacity-70 z-50 flex items-center justify-center hidden">
        <div class="bg-secondary-dark p-6 rounded-xl shadow-2xl max-w-md w-full relative border border-primary-orange/50" onclick="event.stopPropagation()">
            <button onclick="document.getElementById('group-selection-modal').classList.add('hidden')" 
                    class="absolute top-3 right-3 text-muted-text hover:text-light-text transition">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>

            <h3 class="text-2xl font-bold mb-4 text-primary-orange">Select a Group</h3>

            <div id="group-selection-list" class="max-h-56 overflow-y-auto mb-4 space-y-2 p-1">
                <!-- groups injected here -->
            </div>

            <div class="flex items-center justify-between">
                <button onclick="showCreateGroupModal()" class="py-2 px-3 bg-primary-orange text-primary-dark rounded-lg font-bold">Create Group</button>
                <button onclick="document.getElementById('group-selection-modal').classList.add('hidden')" class="py-2 px-3 bg-gray-700 text-light-text rounded-lg">Close</button>
            </div>
        </div>
    </div>

    <!-- Create group modal -->
    <div id="create-group-modal" class="fixed inset-0 bg-primary-dark bg-opacity-70 z-50 flex items-center justify-center hidden">
        <div class="bg-secondary-dark p-6 rounded-xl shadow-2xl max-w-sm w-full relative border border-primary-orange/50" onclick="event.stopPropagation()">
            <button onclick="document.getElementById('create-group-modal').classList.add('hidden')" 
                    class="absolute top-3 right-3 text-muted-text hover:text-light-text transition">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>

            <h3 class="text-2xl font-bold mb-4 text-primary-orange">Create Group</h3>
            <div class="mb-4">
                <label class="block text-sm text-light-text mb-1">Group Name</label>
                <input id="create-group-name" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 text-light-text" placeholder="e.g. Favorites">
            </div>
            <div class="flex space-x-2">
                <button onclick="createGroup()" class="flex-1 py-2 bg-primary-orange text-primary-dark font-bold rounded-lg">Create</button>
                <button onclick="document.getElementById('create-group-modal').classList.add('hidden')" class="flex-1 py-2 bg-gray-700 text-light-text rounded-lg">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Confirmation modal for deleting an anime -->
    <div id="confirm-delete-modal" class="fixed inset-0 bg-primary-dark bg-opacity-70 z-50 flex items-center justify-center hidden">
        <div class="bg-secondary-dark p-6 rounded-xl shadow-2xl max-w-sm w-full relative border border-primary-orange/50" onclick="event.stopPropagation()">
            <button onclick="cancelDelete()" 
                    class="absolute top-3 right-3 text-muted-text hover:text-light-text transition">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>

            <h3 class="text-2xl font-bold mb-4 text-primary-orange">Confirm Removal</h3>
            <p id="confirm-delete-message" class="text-light-text mb-6">Do you want to remove this anime?</p>

            <div class="flex space-x-2">
                <button onclick="cancelDelete()" 
                        class="flex-1 py-2 bg-gray-700 text-light-text font-bold rounded-lg transition duration-200 hover:bg-gray-600">
                    Cancel
                </button>
                <button onclick="confirmDelete()" 
                        class="flex-1 py-2 bg-red-500 text-primary-dark font-bold rounded-lg transition duration-200 hover:bg-red-400">
                    Delete
                </button>
            </div>
        </div>
    </div>
    
    <!-- Confirmation modal for deleting a GROUP -->
    <div id="confirm-delete-group-modal" class="fixed inset-0 bg-primary-dark bg-opacity-70 z-50 flex items-center justify-center hidden">
        <div class="bg-secondary-dark p-6 rounded-xl shadow-2xl max-w-sm w-full relative border border-primary-orange/50" onclick="event.stopPropagation()">
            <button onclick="cancelGroupDelete()" 
                    class="absolute top-3 right-3 text-muted-text hover:text-light-text transition">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>

            <h3 class="text-2xl font-bold mb-4 text-primary-orange">Delete Group</h3>
            <p id="confirm-delete-group-message" class="text-light-text mb-6">Are you sure you want to delete this group?</p>

            <div class="flex space-x-2">
                <button onclick="cancelGroupDelete()" 
                        class="flex-1 py-2 bg-gray-700 text-light-text font-bold rounded-lg transition duration-200 hover:bg-gray-600">
                    Cancel
                </button>
                <button onclick="confirmGroupDelete()" 
                        class="flex-1 py-2 bg-red-500 text-primary-dark font-bold rounded-lg transition duration-200 hover:bg-red-400">
                    Delete
                </button>
            </div>
        </div>
    </div>


    <script>
        const JIKAN_API_URL = 'https://api.jikan.moe/v4/anime';
        
        // Storage Keys
        const ALL_USERS_KEY = 'animeTrackerAllUsers'; 
        const ACTIVE_USER_ID_KEY = 'animeTrackerActiveUserId'; 
        const ENCRYPTED_LIST_PREFIX = 'animeTrackerEncryptedList_'; 
    const FILTER_STORAGE_KEY = 'animeTrackerFilters';
    const GROUPS_STORAGE_KEY = 'animeTrackerGroups';
    const GROUP_FILTER_KEY = 'animeTrackerGroupFilter';

        // PBKDF2 Constants
        const PBKDF2_ITERATIONS = 100000;
        const SALT_LENGTH = 16; // 16 bytes = 128 bits
        const KEY_ALGORITHM = { name: "AES-GCM", length: 256 };
        
        const CATEGORIES = ['Pending', 'Watching', 'Watched'];
        
        let animeList = [];
    let groups = []; // { id, name }
    let activeGroupFilter = null; // null = all
        let lastAPICall = 0;
        const RATE_LIMIT_MS = 1000; 
        
        // --- USER AND ENCRYPTION VARIABLES (UPDATED) ---
        // Structure: { id: 'uuid', username: 'Name', salt: 'base64', iterations: 100000 }
        let allUsers = []; 
        let currentUser = null; // { id: 'uuid', username: 'Name', key: CryptoKey object }
        const IV_LENGTH = 12; // AES-GCM uses 12-byte IV
        // ------------------------------------------
        
        // --- CACHING VARIABLES FOR OPTIMIZATION ---
        let lastQuery = ''; 
        let lastJikanResultsCache = []; 
        // ------------------------------------------

        // Default sort: Newest first
        let currentSortKey = 'timestamp_desc'; 
        let activeFilters = { 'Pending': true, 'Watching': true, 'Watched': true }; 

        const searchInput = document.getElementById('search-input');
        const searchResultsDiv = document.getElementById('search-results');
        const searchMessageDiv = document.getElementById('search-message');
        const trackingListDiv = document.getElementById('tracking-list');
        const emptyListMessage = document.getElementById('empty-list-message');
        const loadingIndicator = document.getElementById('loading-indicator');
        const toastElement = document.getElementById('toast-message');
        const clearButton = document.getElementById('clear-search-btn');
        const sortSelect = document.getElementById('sort-select');
        const filterControlsDiv = document.getElementById('filter-controls');
        const usernameDisplay = document.getElementById('current-username');

        // --- Long Press Feature Variables ---
        const LONG_PRESS_DURATION = 500; // milliseconds
        let pressTimer = null;
        let isLongPressing = false; 
        let currentlyPressedId = null; 
        // ------------------------------------
        
        // --- ENCRYPTION & KEY DERIVATION UTILITIES (UPDATED) ---

        /**
         * Converts a string (Base64) to an ArrayBuffer.
         */
        function str2ab(base64Str) {
            const binary_string = window.atob(base64Str);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Converts an ArrayBuffer to a string (Base64).
         */
        function ab2str(buffer) {
            return window.btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));
        }

        /**
         * Derives an AES-GCM key from a password and salt using PBKDF2.
         * @param {string} password - The user's password.
         * @param {string} base64Salt - The salt stored in the user profile (Base64 encoded).
         * @returns {Promise<CryptoKey>} The derived AES-GCM key.
         */
        async function deriveKey(password, base64Salt) {
            // base64Salt is expected to be a Base64 string representing the salt bytes
            const saltBuf = new Uint8Array(str2ab(base64Salt));
            const pwUtf8 = new TextEncoder().encode(password);

            // Import the raw password as a key for PBKDF2
            const baseKey = await crypto.subtle.importKey(
                'raw', pwUtf8, { name: 'PBKDF2' }, false, ['deriveKey']
            );

            // Derive an AES-GCM key using PBKDF2
            const derivedKey = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: saltBuf,
                    iterations: PBKDF2_ITERATIONS,
                    hash: 'SHA-256'
                },
                baseKey,
                KEY_ALGORITHM,
                false,
                ['encrypt', 'decrypt']
            );

            return derivedKey;
        }

        /**
         * Encrypts the anime list data using AES-GCM and the user's key.
         */
        async function encryptData(data) {
            if (!currentUser || !currentUser.key) throw new Error("Encryption key not available.");

            const jsonString = JSON.stringify(data);
            const dataBuffer = new TextEncoder().encode(jsonString);
            const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH)); // Generate random IV

            const encryptedBuffer = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                currentUser.key,
                dataBuffer
            );

            // Combine IV and encrypted data for storage
            const combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);
            combined.set(iv, 0);
            combined.set(new Uint8Array(encryptedBuffer), iv.length);

            return ab2str(combined.buffer); // Store as Base64 string
        }

        /**
         * Decrypts the Base64-encoded data using AES-GCM and the user's key.
         */
        async function decryptData(base64Encrypted) {
            if (!currentUser || !currentUser.key) throw new Error("Decryption key not available.");
            if (!base64Encrypted) return [];

            const combinedBuffer = str2ab(base64Encrypted);
            const combinedArray = new Uint8Array(combinedBuffer);

            // Separate IV and encrypted data
            const iv = combinedArray.slice(0, IV_LENGTH);
            const encryptedData = combinedArray.slice(IV_LENGTH);

            const decryptedBuffer = await crypto.subtle.decrypt(
                { name: "AES-GCM", iv: iv },
                currentUser.key,
                encryptedData
            );

            const jsonString = new TextDecoder().decode(decryptedBuffer);
            return JSON.parse(jsonString);
        }

        // --- USER MANAGEMENT (REFACTORED) ---

        /**
         * Generates a random UUID (simple version).
         */
        function generateUUID() {
            return 'xxxx-xxxx-4xxx-yxxx-xxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        /**
         * Loads all user profiles from storage. Creates a default user if none exist.
         */
        function loadAllUsers() {
            const storedUsers = localStorage.getItem(ALL_USERS_KEY);

            if (storedUsers) {
                try {
                    allUsers = JSON.parse(storedUsers);
                    // Filter out any old format users (those with jwk) for security/migration simplicity
                    allUsers = allUsers.filter(u => u.salt); 
                } catch(e) {
                    console.error("Error parsing user list, resetting allUsers.");
                    allUsers = [];
                }
            }
            
            // If no users remain after filtering/loading, create the initial user
            if (!allUsers || allUsers.length === 0) {
                console.log("No secure users found. Creating initial user.");
                const initialUserId = generateUUID();
                // Note: The new user will be created with default credentials
                addNewUser(initialUserId, initialUserId, "default", true); 
                saveAllUsers(); // Save the new default user list
            }
        }
        
        /**
         * Saves the current allUsers array to storage.
         */
        function saveAllUsers() {
            localStorage.setItem(ALL_USERS_KEY, JSON.stringify(allUsers));
        }

        /**
         * Derives key, sets the provided user ID as the active user, and loads data.
         * Password validation check is handled by the subsequent decryption attempt in loadList.
         * @param {string} userId - The ID of the user to activate.
         * @param {string} password - The password for key derivation.
         * @returns {Promise<boolean>} True if login was successful, false otherwise.
         */
        async function setActiveUser(userId, password) {
            const userProfile = allUsers.find(u => u.id === userId);

            if (!userProfile) {
                showToast(`Error: User ID ${userId} not found.`);
                return false;
            }

            try {
                // 1. Derive the key from password and salt
                const derivedKey = await deriveKey(password, userProfile.salt);
                
                // 2. Set the current user state (TEMPORARILY set, will be cleared on failure)
                currentUser = { 
                    id: userProfile.id, 
                    username: userProfile.username, 
                    key: derivedKey 
                };
                
                // 3. Load the encrypted list specific to this user (Triggers password check/decryption)
                // If the key is wrong, loadList will throw an error and we jump to the catch block.
                await loadList(); 
                
                // If we reach here, the password was correct. Finalize the state.
                localStorage.setItem(ACTIVE_USER_ID_KEY, userId); // Save as active
                usernameDisplay.textContent = `User: ${currentUser.username}`;
                
                showToast(`Switched to user: ${currentUser.username}`);
                
                // 4. Close modals
                hideModal('login-modal');
                hideModal('user-select-modal');
                hideModal('data-transfer-modal');
                
                return true;

            } catch (error) {
                console.error("Login attempt failed:", error);

                // IMPORTANT: Clear the potentially incorrect key from memory and UI state
                currentUser = null;
                document.getElementById('login-password').value = ''; 
                
                let errorMessage = `Login failed for ${userProfile.username}. Please try again.`;

                if (error.message === "INCORRECT_PASSWORD") {
                    errorMessage = `Incorrect password for user: ${userProfile.username}.`;
                } else {
                    errorMessage = `Login error for ${userProfile.username}. Data may be corrupted.`;
                }
                
                showToast(errorMessage);
                
                return false;
            }
        }

        /**
         * Creates a new user profile with a derived key.
         */
        async function addNewUser(id, username, password, isInitialSetup = false) {
            try {
                // 1. Generate unique salt
                const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
                const base64Salt = ab2str(salt.buffer);

                // 2. Add the user profile (salt is stored, not the key)
                const newUserProfile = { 
                    id: id, 
                    username: username,
                    salt: base64Salt,
                    iterations: PBKDF2_ITERATIONS // For future proofing/flexibility
                };
                
                allUsers.push(newUserProfile);
                saveAllUsers();
                
                if (!isInitialSetup) {
                    await setActiveUser(id, password);
                    showToast(`User "${username}" created and set as active.`);
                    renderUserList(); 
                    hideModal('register-modal');
                }

            } catch (error) {
                console.error("Error creating new user:", error);
                showToast("Error creating new user. See console.");
            }
        }
        
        /**
         * Deletes a user profile and their encrypted data.
         */
        function deleteUser(userId) {
            if (allUsers.length === 1) {
                showToast("Cannot delete the only remaining user.");
                return;
            }
            
            if (currentUser && currentUser.id === userId) {
                 showToast("Cannot delete the currently active user. Switch first.");
                 return;
            }

            const userToDelete = allUsers.find(u => u.id === userId);
            const confirmDelete = window.confirm(`Are you sure you want to delete user ${userToDelete.username} and ALL their tracking data? This cannot be undone.`);
            
            if (confirmDelete) {
                allUsers = allUsers.filter(u => u.id !== userId);
                saveAllUsers();
                
                // Also delete the encrypted list data for that user
                localStorage.removeItem(ENCRYPTED_LIST_PREFIX + userId);
                
                showToast(`User ${userToDelete.username} and their data deleted.`);
                renderUserList();
            }
        }

        /**
         * Initializes user system: loads all users and sets the active user.
         */
        async function initializeUser() {
            // 1. Load all users (creates initial user if none exist)
            loadAllUsers(); 

            // 2. Determine the active user ID
            let activeId = localStorage.getItem(ACTIVE_USER_ID_KEY);
            
            // Fallback: If no active ID is set, or the stored ID is not secure, use the first user.
            if (!activeId || !allUsers.some(u => u.id === activeId)) {
                if (allUsers.length > 0) {
                    activeId = allUsers[0].id;
                    localStorage.setItem(ACTIVE_USER_ID_KEY, activeId);
                } else {
                    // This case should be handled by loadAllUsers() creating the first user, 
                    // but is a safeguard.
                    usernameDisplay.textContent = 'Setup Required';
                    showRegisterModal(true); // Force registration
                    return;
                }
            }
            
            // 3. Trigger login modal for the active user if it's not the initial 'default' setup attempt
            const userProfile = allUsers.find(u => u.id === activeId);
            if(userProfile) {
                // If it's the very first time loading, and it's the auto-created user,
                // try to log in with "default" automatically to get the app running.
                const isFirstTimeUser = allUsers.length === 1 && activeId === userProfile.id && localStorage.getItem(ENCRYPTED_LIST_PREFIX + activeId) === null;
                
                if (isFirstTimeUser) {
                    // Attempt silent login with the default password
                    const success = await setActiveUser(activeId, "default");
                    if (!success) {
                         // If the silent login failed (e.g. data corruption), fall back to manual login
                        showUserSelectModal();
                    }
                } else {
                    // Normal behavior: prompt for password
                    handleUserSwitchAttempt(activeId);
                }
            } else {
                 usernameDisplay.textContent = 'Setup Required';
                 showRegisterModal(true);
            }

            lucide.createIcons();
        }

        // --- Message and Visibility Functions ---
        
        /**
         * Utility function to hide any modal.
         */
        function hideModal(id) {
            document.getElementById(id).classList.add('hidden');
        }

        /**
         * Shows a temporary toast message to the user.
         */
        function showToast(message) {
            toastElement.textContent = message;
            toastElement.classList.remove('hidden', 'opacity-0');
            toastElement.classList.add('opacity-100');
            setTimeout(() => {
                toastElement.classList.remove('opacity-100');
                toastElement.classList.add('opacity-0');
                setTimeout(() => {
                    toastElement.classList.add('hidden');
                }, 300);
            }, 3000);
        }

        // --- List Data Functions ---

        /**
         * Loads the anime list from localStorage (Encrypted).
         * Throws an error if decryption fails (signals incorrect password/key).
         */
        async function loadList() {
            if (!currentUser) {
                console.error("Attempted to load list without an active user.");
                animeList = [];
                return;
            }
            
            const listKey = ENCRYPTED_LIST_PREFIX + currentUser.id;
            const storedEncryptedList = localStorage.getItem(listKey);

            if (storedEncryptedList) {
                try {
                    // Decrypt using the current user's active key
                    animeList = await decryptData(storedEncryptedList);
                } catch (error) {
                    // This is the check: If the list exists but the key derived from the password fails to decrypt it, 
                    // we assume the password was incorrect and propagate an error to setActiveUser.
                    console.error("Decryption failure during load (wrong key/password):", error);
                    throw new Error("INCORRECT_PASSWORD"); 
                }
            } else {
                animeList = [];
            }
            
            // Standardize and validate list data
            animeList = animeList.map(anime => ({
                ...anime,
                category: anime.category || 'Pending',
                timestamp: anime.timestamp || Date.now() 
            }));

            if (sortSelect) sortSelect.value = currentSortKey;
            loadFilters();
            renderFilterControls();
            renderTrackingList();
            updateSearchMessageVisibility();
        }

        /**
         * Saves the current anime list to localStorage (Encrypted).
         */
        async function saveList() {
            if (!currentUser) {
                 console.error("Attempted to save list without an active user.");
                 return;
            }
            
            const listKey = ENCRYPTED_LIST_PREFIX + currentUser.id;

            try {
                const encryptedList = await encryptData(animeList); // Uses currentUser.key
                localStorage.setItem(listKey, encryptedList);
                
                renderFilterControls(); 
                renderTrackingList();
                updateSearchMessageVisibility(); 

                const currentQuery = searchInput.value.trim();
                if (currentQuery.length >= 3) {
                    handleSearch(currentQuery); 
                }
            } catch (error) {
                console.error("Error encrypting or saving list:", error);
                showToast("Error saving data. Please check console.");
            }
        }
        
        // --- DATA TRANSFER FUNCTIONS (NEW) ---
        
        /**
         * Exports the current user's profile and encrypted list data as a downloadable JSON file.
         */
        function exportUserData() {
             if (!currentUser) {
                showToast("Error: No active user to export.");
                return;
            }
            
            // 1. Get the current user profile (which contains the salt/iterations)
            const userProfile = allUsers.find(u => u.id === currentUser.id);
            if (!userProfile) {
                showToast("Error: User profile not found in system.");
                return;
            }
            
            // 2. Get the encrypted data string
            const encryptedList = localStorage.getItem(ENCRYPTED_LIST_PREFIX + currentUser.id);
            
            if (!encryptedList) {
                 const confirmExportEmpty = window.confirm(`User ${currentUser.username} has no saved list data. Export profile only?`);
                 if (!confirmExportEmpty) return;
            }

            // 3. Create the backup object
            const backupData = {
                __backup_version: '1.0',
                user_profile: {
                    id: userProfile.id,
                    username: userProfile.username,
                    salt: userProfile.salt,
                    iterations: userProfile.iterations 
                },
                encrypted_list_data: encryptedList,
                backup_timestamp: new Date().toISOString()
            };

            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(backupData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", `anime_tracker_backup_${userProfile.username}_${Date.now()}.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            
            showToast("Export successful! Backup file downloaded.");
            hideModal('data-transfer-modal');
        }

        /**
         * Handles the file input for importing user data.
         */
        function handleImportFile(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    await importUserData(data);
                } catch (error) {
                    console.error("Import failed:", error);
                    showToast("Import failed: File is corrupted or not a valid JSON backup.");
                }
            };
            reader.readAsText(file);
        }
        
        /**
         * Imports the user data from a parsed backup object.
         */
        async function importUserData(backupData) {
            if (backupData.__backup_version !== '1.0' || !backupData.user_profile || !backupData.encrypted_list_data) {
                showToast("Import failed: Backup file structure is invalid.");
                return;
            }

            const profile = backupData.user_profile;
            const encryptedList = backupData.encrypted_list_data;
            let newId = profile.id;
            let newUsername = profile.username;
            
            // Handle ID conflict
            if (allUsers.some(u => u.id === profile.id)) {
                newId = generateUUID();
                newUsername = `${profile.username} (Imported - ${newId.substring(0, 4)})`;
            }
            
            // 1. Create the new user profile based on imported salt/iterations
            const newUserProfile = {
                id: newId,
                username: newUsername,
                salt: profile.salt,
                iterations: profile.iterations 
            };
            
            allUsers.push(newUserProfile);
            saveAllUsers();

            // 2. Save the encrypted data for the new user's storage key
            localStorage.setItem(ENCRYPTED_LIST_PREFIX + newId, encryptedList);

            showToast(`User "${newUsername}" imported successfully! You must now log in with the **original password** for this profile.`);
            
            // 3. Prompt user to switch to the imported profile
            hideModal('data-transfer-modal');
            renderUserList();
            handleUserSwitchAttempt(newId);
        }
        
        /**
         * Shows the data transfer modal.
         */
        function showDataTransferModal() {
            hideModal('user-select-modal');
            const modal = document.getElementById('data-transfer-modal');
            modal.classList.remove('hidden');
            
            // Update the username in the export section
            const exportText = modal.querySelector('.p-4:nth-child(1) p');
            if (exportText && currentUser) {
                 exportText.innerHTML = `Creates a JSON file containing the encrypted list and user settings for **${currentUser.username}**.`;
            }
            
            // Clear file input from previous use
            document.getElementById('import-file-input').value = ''; 
        }

        // --- Modal/UI Logic (New & Updated) ---
        
        /**
         * Renders the list of users in the modal.
         */
        function renderUserList() {
            const userListDiv = document.getElementById('user-list');
            if (!userListDiv) return;

            userListDiv.innerHTML = allUsers.map(user => {
                const isActive = currentUser && currentUser.id === user.id;
                const baseClasses = 'flex items-center justify-between p-3 rounded-lg border transition duration-150';
                
                const classes = isActive 
                    ? `${baseClasses} bg-primary-orange/20 border-primary-orange text-light-text font-semibold`
                    : `${baseClasses} bg-gray-700 border-gray-700 hover:bg-gray-600 text-muted-text hover:text-light-text cursor-pointer`;
                
                return `
                    <div class="${classes}">
                        <div onclick="${isActive ? '' : `handleUserSwitchAttempt('${user.id}')`}" class="flex-grow flex items-center">
                            <span data-lucide="${isActive ? 'user-check' : 'user'}" class="w-5 h-5 mr-3 ${isActive ? 'text-primary-orange' : 'text-muted-text'}"></span>
                            <span class="font-semibold text-sm" title="${user.id}">${user.username}</span>
                            ${isActive ? '<span class="ml-2 px-2 py-0.5 text-xs bg-primary-orange text-primary-dark rounded-full">Active</span>' : ''}
                        </div>
                        
                        <button onclick="deleteUser('${user.id}')" 
                                class="ml-4 text-muted-text hover:text-red-500 p-1 rounded-full ${isActive ? 'opacity-50 cursor-not-allowed' : ''}"
                                ${isActive ? 'disabled' : ''}>
                            <span data-lucide="trash-2" class="w-4 h-4"></span>
                        </button>
                    </div>
                `;
            }).join('');
            
            lucide.createIcons();
        }
        
        /**
         * Shows the user selection modal and populates the list.
         */
        function showUserSelectModal() {
            loadAllUsers(); 
            renderUserList(); 
            
            const modal = document.getElementById('user-select-modal');
            modal.classList.remove('hidden');
            
            // Add click outside listener on the modal backdrop
            modal.onclick = (event) => {
                if (event.target === modal) {
                    hideModal('user-select-modal');
                }
            };
        }
        
        /**
         * Shows the new user registration modal.
         */
        function showRegisterModal(isForced = false) {
            hideModal('user-select-modal');
            const modal = document.getElementById('register-modal');
            modal.classList.remove('hidden');
            document.getElementById('register-username').value = '';
            document.getElementById('register-password').value = '';

            // If forced (no users exist), hide the close button
            const closeBtn = modal.querySelector('button[onclick="hideModal(\'register-modal\'); showUserSelectModal();"]');
            if (closeBtn) closeBtn.style.display = isForced ? 'none' : 'block';
        }

        /**
         * Handles the form submission for new user registration.
         */
        async function handleNewUserRegistration() {
            const username = document.getElementById('register-username').value.trim();
            const password = document.getElementById('register-password').value;
            
            if (allUsers.some(u => u.username.toLowerCase() === username.toLowerCase())) {
                showToast(`Username "${username}" already exists.`);
                return;
            }

            if (!username || !password || password.length < 6) {
                showToast("Username and a password of at least 6 characters are required.");
                return;
            }
            
            const newId = generateUUID();
            await addNewUser(newId, username, password, false);
        }

        /**
         * Sets up the password prompt for a user switch attempt.
         */
        function handleUserSwitchAttempt(userId) {
            hideModal('user-select-modal');
            
            const userProfile = allUsers.find(u => u.id === userId);
            if (!userProfile) return;

            document.getElementById('login-username').textContent = `Switching to: ${userProfile.username}`;
            document.getElementById('login-user-id').value = userId;
            document.getElementById('login-password').value = '';
            
            const modal = document.getElementById('login-modal');
            modal.classList.remove('hidden');
            
            // Add click outside listener on the modal backdrop
            modal.onclick = (event) => {
                if (event.target === modal) {
                    hideModal('login-modal');
                    showUserSelectModal();
                }
            };
        }
        
        /**
         * Handles the login form submission.
         */
        async function loginUser() {
            const userId = document.getElementById('login-user-id').value;
            const password = document.getElementById('login-password').value;
            
            if (!password) {
                showToast("Password is required.");
                return;
            }
            
            await setActiveUser(userId, password);
            // setActiveUser now handles all UI state changes for both success and failure (via the confirm prompt).
        }
        
        // --- Other functions (startLongPress, endLongPress, etc.) omitted for brevity but remain functional ---
        
        /**
         * Utility function for debouncing API calls.
         */
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            }; // FIX: Removed extraneous '), 500)' which caused SyntaxError
        }
        
        function updateSearchMessageVisibility() {
            if (animeList.length > 0) {
                searchMessageDiv.classList.add('hidden');
            } else {
                searchMessageDiv.textContent = 'Search for an anime to begin tracking!';
                searchMessageDiv.classList.remove('hidden');
            }
        }
        
        function clearSearch() {
            searchInput.value = '';
            searchResultsDiv.innerHTML = '';
            clearButton.classList.add('hidden');
            loadingIndicator.classList.add('hidden');
            updateSearchMessageVisibility(); 
            lastQuery = '';
            lastJikanResultsCache = [];
        }

        function toggleClearButton() {
            if (searchInput.value.trim().length > 0) {
                clearButton.classList.remove('hidden');
            } else {
                clearButton.classList.add('hidden');
            }
        }

        function addAnimeToList(animeData) {
			animeData = JSON.parse(urlSafeBase64Decode(animeData));
            if (animeList.some(a => a.id === animeData.mal_id)) {
                showToast(`${animeData.title} is already in your list!`);
                return;
            }

            const newAnime = {
                id: animeData.mal_id,
                title: animeData.title,
                total_episodes: animeData.episodes || 0, // Use 0 if episodes is null/unknown
                watched_episodes: 0,
                image_url: animeData.images.webp.image_url,
                status: animeData.status,
                category: 'Pending', // Initialize with Pending
                timestamp: Date.now() // Add timestamp for sorting
            };

            animeList.push(newAnime);
            saveList(); 
            showToast(`Added "${newAnime.title}" to your list!`);
            // Replace the corresponding search-result card (if present) with the tracked anime card
            try {
                const searchResultEl = document.getElementById(`search-result-${newAnime.id}`);
                if (searchResultEl) {
                    searchResultEl.outerHTML = generateTrackedAnimeCardHtml(newAnime, true);
                    // Recreate icons in the newly inserted HTML
                    lucide.createIcons();
                    // Add a temporary highlight animation to the newly inserted tracked card
                    try {
                        const insertedEl = document.getElementById(`tracked-anime-${newAnime.id}`);
                        if (insertedEl) {
                            insertedEl.classList.add('replace-highlight');
                            // Remove the class after the animation completes
                            setTimeout(() => insertedEl.classList.remove('replace-highlight'), 900);
                        }
                    } catch (innerErr) {
                        console.warn('Could not apply replacement animation:', innerErr);
                    }
                }
            } catch (e) {
                // Non-fatal: if replacement fails, just continue
                console.warn('Could not replace search result card:', e);
            }

            //Manually clear the search to add multiple items.
            //clearSearch(); 
        }

        function removeAnimeFromList(id) {
            animeList = animeList.filter(a => a.id !== id);
            saveList(); 
            showToast('Anime removed from list.');
        }

        function updateEpisodeCount(id, newCount) {
            const anime = animeList.find(a => a.id === id);
            if (anime) {
                const total = anime.total_episodes;
                const isIncrement = newCount > anime.watched_episodes;
                newCount = Math.max(0, Math.min(newCount, total || 9999));
                
                if (newCount > 0 && total > 0 && newCount >= total) {
                    if (anime.category !== 'Watched') {
                        anime.category = 'Watched';
                        showToast(`Congratulations! "${anime.title}" is now marked as Watched.`);
                    }
                } 
                else if (isIncrement && newCount > 0 && anime.category === 'Pending') {
                    anime.category = 'Watching';
                    showToast(`Starting to watch "${anime.title}". Status set to Watching.`);
                } else if (newCount < total && anime.category === 'Watched') {
                    anime.category = 'Watching';
                } else if (newCount === 0 && anime.category !== 'Pending') {
                    anime.category = 'Pending';
                }

                anime.watched_episodes = newCount;
                saveList(); 
            }
        }
        
        function handleEpisodeInputChange(id, element) {
            const newCount = parseInt(element.value);
            if (!isNaN(newCount)) {
                updateEpisodeCount(id, newCount);
            }
        }
        
        function updateAnimeCategory(id, element) {
            const newCategory = element.value;
            const anime = animeList.find(a => a.id === id);
            if (anime) {
                anime.category = newCategory;
                if (newCategory === 'Watched' && anime.total_episodes > 0) {
                    anime.watched_episodes = anime.total_episodes;
                }
                if (newCategory === 'Pending') {
                    anime.watched_episodes = 0;
                }
                saveList(); 
                showToast(`Category for "${anime.title}" set to ${newCategory}.`);
            }
        }

        function sortAndRenderList(sortKey) {
            currentSortKey = sortKey;
            renderTrackingList();
        }

        function loadFilters() {
            const storedFilters = localStorage.getItem(FILTER_STORAGE_KEY);
            if (storedFilters) activeFilters = JSON.parse(storedFilters);
        }

        function loadGroups() {
            const stored = localStorage.getItem(GROUPS_STORAGE_KEY);
            if (stored) {
                try {
                    groups = JSON.parse(stored);
                } catch (e) {
                    console.error('Failed to parse groups from storage', e);
                    groups = [];
                }
            } else {
                groups = [];
            }
            // Load saved active group filter (validate against existing groups)
            const storedFilter = localStorage.getItem(GROUP_FILTER_KEY);
            activeGroupFilter = storedFilter ? storedFilter : null;
            if (activeGroupFilter && !groups.some(g => g.id === activeGroupFilter)) {
                activeGroupFilter = null;
                localStorage.removeItem(GROUP_FILTER_KEY);
            }
        }

        function saveGroups() {
            localStorage.setItem(GROUPS_STORAGE_KEY, JSON.stringify(groups));
            // Update filter controls when groups change
            try { renderFilterControls(); } catch (e) { /* safe-fail */ }
        }

        function setActiveGroupFilter(value) {
            // value: '' or undefined => clear filter (show all)
            activeGroupFilter = value || null;
            if (activeGroupFilter === '') activeGroupFilter = null;
            if (activeGroupFilter && !groups.some(g => g.id === activeGroupFilter)) {
                activeGroupFilter = null;
            }
            if (activeGroupFilter) {
                localStorage.setItem(GROUP_FILTER_KEY, activeGroupFilter);
            } else {
                localStorage.removeItem(GROUP_FILTER_KEY);
            }
            renderFilterControls();
            renderTrackingList();
        }

        function saveFilters() {
            localStorage.setItem(FILTER_STORAGE_KEY, JSON.stringify(activeFilters));
        }

        function toggleFilter(category) {
            if (activeFilters.hasOwnProperty(category)) {
                const activeCount = Object.values(activeFilters).filter(v => v).length;
                if (activeFilters[category] === true && activeCount === 1) {
                    showToast("At least one category must remain visible.");
                    return;
                }

                activeFilters[category] = !activeFilters[category];
                saveFilters(); 
                renderFilterControls(); 
                renderTrackingList(); 
            }
        }
        
        function renderFilterControls() {
            if (!filterControlsDiv) return;

            // Build group filter dropdown (left) if groups exist
            let groupHtml = '';
            if (groups && groups.length > 0) {
                groupHtml = `
                    <div class="flex items-center mr-4">
                        <label for="group-filter-select" class="text-muted-text text-sm mr-2 hidden sm:inline">Filter by Group:</label>
                        <select id="group-filter-select" onchange="setActiveGroupFilter(this.value)" class="px-3 py-2 pr-12 rounded-lg bg-gray-700 border border-gray-700 text-light-text text-sm">
                            <option value="">All Groups</option>
                            ${groups.map(g => `<option value="${g.id}" ${activeGroupFilter === g.id ? 'selected' : ''}>${escapeHtml(g.name)}</option>`).join('')}
                        </select>
                    </div>
                `;
            }

            const categoriesHtml = CATEGORIES.map(category => {
                const isActive = activeFilters[category];
                const count = animeList.filter(a => a.category === category).length;
                let classes = 'px-4 py-2 rounded-lg font-semibold transition-all duration-200 shadow-md text-sm';
                let colorMap = {
                    'Pending': 'border-gray-500 bg-gray-700 hover:bg-gray-600',
                    'Watching': 'border-primary-orange bg-primary-orange/50 hover:bg-primary-orange/70',
                    'Watched': 'border-green-500 bg-green-700 hover:bg-green-600'
                };

                if (isActive) {
                    classes += ` border-2 text-light-text ${colorMap[category]}`;
                } else {
                    classes += ' border-2 border-gray-700 bg-gray-900 text-muted-text opacity-50 hover:opacity-75';
                }

                return `<button 
                            onclick="toggleFilter('${category}')" 
                            class="${classes}"
                        >
                            ${category} (${count})
                        </button>`;
            }).join('');

            filterControlsDiv.innerHTML = `
                <div class="flex items-center justify-between w-full">
                    <div class="flex items-center space-x-2 flex-1">
                        ${categoriesHtml}
                    </div>
                    <div class="flex items-center space-x-3 ml-4">
                        ${groupHtml}
                        <div class="flex items-center space-x-2">
                            <label for="sort-select" class="text-muted-text text-sm hidden sm:block">Sort By:</label>
                            <select id="sort-select" onchange="sortAndRenderList(this.value)"
                                    class="p-2 rounded-lg bg-gray-700 border border-primary-orange/50 focus:ring-1 focus:ring-primary-orange focus:border-primary-orange text-light-text text-sm cursor-pointer">
                                <option value="timestamp_desc">Date Added (Newest)</option>
                                <option value="timestamp_asc">Date Added (Oldest)</option>
                                <option value="title_asc">Name (A-Z)</option>
                                <option value="title_desc">Name (Z-A)</option>
                            </select>
                        </div>
                    </div>
                </div>
            `;

            lucide.createIcons();
        }

        async function searchJikanAPI(query) {
            const now = Date.now();
            if (now - lastAPICall < RATE_LIMIT_MS) {
                await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_MS - (now - lastAPICall)));
            }
            lastAPICall = Date.now();

            try {
                const url = `${JIKAN_API_URL}?q=${encodeURIComponent(query)}&limit=8`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API returned status ${response.status}`);
                }
                
                const data = await response.json();
                return data.data || []; 
            } catch (error) {
                console.error("Error fetching anime from Jikan:", error);
                throw new Error("API_ERROR"); 
            }
        }
        
        function searchLocalList(query) {
            if (!query) return [];
            const lowerQuery = query.toLowerCase();
            return animeList
                .filter(anime => anime.title.toLowerCase().includes(lowerQuery))
                .map(anime => ({
                    mal_id: anime.id,
                    is_local: true, 
                }));
        }


        async function handleSearch(query) {
            query = query.trim();

            if (query.length < 3) {
                searchResultsDiv.innerHTML = '';
                searchMessageDiv.textContent = 'Please enter at least 3 characters to search.';
                searchMessageDiv.classList.remove('hidden');
                loadingIndicator.classList.add('hidden');
                return;
            }
            
            searchResultsDiv.innerHTML = '';
            searchMessageDiv.classList.add('hidden');
            loadingIndicator.classList.remove('hidden');
            
            const localResults = searchLocalList(query);
            let jikanResults = [];
            let apiError = false;
            const localIds = new Set(localResults.map(r => r.mal_id));
            const isSameQuery = (query === lastQuery);

            if (!isSameQuery) {
                try {
                    jikanResults = await searchJikanAPI(query);
                    lastJikanResultsCache = jikanResults; 
                    lastQuery = query; 
                } catch (error) {
                    if (error.message === "API_ERROR") apiError = true;
                    lastJikanResultsCache = []; 
                    lastQuery = ''; 
                }
            } else {
                jikanResults = lastJikanResultsCache;
            }
            
            loadingIndicator.classList.add('hidden');

            const uniqueJikanResults = jikanResults.filter(jikanAnime => {
                return !localIds.has(jikanAnime.mal_id);
            });
            
            let allResults = localResults.concat(uniqueJikanResults);
            
            if (apiError) {
                searchResultsDiv.innerHTML += `
                    <p class="text-red-500 col-span-full p-4 rounded-xl bg-secondary-dark/50 text-center mb-6">
                        Error fetching external data. Displaying local matches only.
                    </p>
                `;
            }

            if (allResults.length === 0) {
                 searchMessageDiv.textContent = apiError ? 
                    'No local matches found.' :
                    'No results found for your query, locally or online.';
                 searchMessageDiv.classList.remove('hidden');
                 return;
            }
            
            renderSearchResults(allResults);
        }

        const debouncedSearch = debounce(() => {
            const query = searchInput.value;
            handleSearch(query);
        }, 500); 


        function generateTrackedAnimeCardHtml(anime, isSearchContext = false) {
            const progressPercent = anime.total_episodes > 0 
                ? (anime.watched_episodes / anime.total_episodes) * 100 
                : 0;
            const isCompleted = anime.watched_episodes >= anime.total_episodes && anime.total_episodes > 0;
            let titleColorClass = 'text-light-text';
            let borderClass = 'border-gray-500';

            switch(anime.category) {
                case 'Watched':
                    titleColorClass = 'text-green-400';
                    borderClass = 'border-green-500';
                    break;
                case 'Watching':
                    titleColorClass = 'text-primary-orange';
                    borderClass = 'border-primary-orange';
                    break;
            }
            
            const progressBarColorClass = isCompleted ? 'bg-green-500' : 'bg-primary-orange';
            const progressTextColorClass = isCompleted ? 'text-green-400' : 'text-light-text';

            return `
                <div id="tracked-anime-${anime.id}" 
                     class="bg-secondary-dark p-4 rounded-xl shadow-2xl flex flex-col border-2 ${borderClass} transition-all duration-300 relative overflow-hidden"
                     style="cursor: pointer;"
                >
                    <div id="long-press-indicator-${anime.id}" class="long-press-indicator"></div>
                    
                    <div class="flex items-start mb-4" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
                        <img src="${anime.image_url}" 
                             onerror="this.onerror=null; this.src='https://placehold.co/80x120/1f2937/9ca3af?text=No+Image'"
                             alt="${anime.title} poster" 
                             class="w-16 h-24 object-cover rounded-lg mr-4 shadow-md">
                        <div class="flex-grow">
                            <h3 class="text-xl font-bold ${titleColorClass} leading-tight" title="${anime.title}">${anime.title}</h3>
                            
                            <select onchange="updateAnimeCategory(${anime.id}, this)"
                                    class="mt-1 mb-2 p-1.5 text-sm rounded-lg bg-gray-700 border border-primary-orange/50 focus:ring-1 focus:ring-primary-orange focus:border-primary-orange text-light-text w-full max-w-[150px] appearance-none cursor-pointer">
                                <option value="Pending" ${anime.category === 'Pending' ? 'selected' : ''}>Pending</option>
                                <option value="Watching" ${anime.category === 'Watching' ? 'selected' : ''}>Watching</option>
                                <option value="Watched" ${anime.category === 'Watched' ? 'selected' : ''}>Watched</option>
                            </select>

                            <p class="text-sm text-muted-text">Total Episodes: <span class="font-semibold">${anime.total_episodes || 'Unknown'}</span></p>
                            <p class="text-xs text-light-text/70">${anime.status || 'N/A'}</p>
                            ${anime.group ? `<p class="text-xs text-muted-text mt-1">Group: <span class="text-primary-orange font-semibold">${escapeHtml(getGroupName(anime.group) || 'Unknown')}</span></p>` : ''}
                        </div>
                        <div class="card-action-wrapper ml-4">
                            <button class="card-action-button" onclick="toggleCardMenu(${anime.id}, event)" onmousedown="event.stopPropagation()" title="Actions">
                                <span data-lucide="more-vertical" class="w-5 h-5"></span>
                            </button>

                                        <div id="card-menu-${anime.id}" class="card-action-menu hidden" onclick="event.stopPropagation()" data-title="${anime.title}">
                                            <button onclick="showGroupSelectionModal(${anime.id})">
                                                <span data-lucide="layers" class="w-4 h-4 inline-block mr-2 align-middle"></span>
                                                Add to group
                                            </button>
                                            <div class="my-1 border-t border-gray-700"></div>
                                            <button class="delete-option" onclick="showDeleteConfirm(${anime.id})">
                                                <span data-lucide="trash-2" class="w-4 h-4 inline-block mr-2 align-middle"></span>
                                                Delete
                                            </button>
                                        </div>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <div class="text-sm font-medium mb-1 ${progressTextColorClass}">
                            ${anime.watched_episodes} / ${anime.total_episodes || '?'} Watched
                        </div>
                        <div class="w-full bg-gray-700 rounded-full h-2.5">
                            <div class="h-2.5 rounded-full ${progressBarColorClass}" 
                                 style="width: ${progressPercent > 100 ? 100 : progressPercent}%"></div>
                        </div>
                    </div>

                    <div class="flex space-x-2 mt-auto" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
                        <button onclick="updateEpisodeCount(${anime.id}, ${anime.watched_episodes - 1})" 
                                class="p-2 bg-primary-orange/30 text-light-text rounded-lg hover:bg-primary-orange/50 transition duration-150">
                            <span data-lucide="minus" class="w-4 h-4"></span>
                        </button>
                        
                        <input type="number" 
                               value="${anime.watched_episodes}" 
                               onchange="handleEpisodeInputChange(${anime.id}, this)"
                               min="0"
                               max="${anime.total_episodes || 9999}"
                               class="w-full text-center p-2 rounded-lg bg-gray-700 border border-primary-orange/50 focus:border-primary-orange focus:ring-1 focus:ring-primary-orange text-light-text font-mono">

                        <button onclick="updateEpisodeCount(${anime.id}, ${anime.watched_episodes + 1})" 
                                class="p-2 bg-primary-orange text-primary-dark rounded-lg hover:bg-orange-500 transition duration-150">
                            <span data-lucide="plus" class="w-4 h-4"></span>
                        </button>
                    </div>
                </div>
            `;
        }
		/**
		 * Encodes a string into a URL-safe Base64 format.
		 * - Handles full UTF-8 support using TextEncoder.
		 * - Replaces '+' with '-' and '/' with '_'.
		 * - Removes '=' padding.
		 * @param {string} str The string to encode.
		 * @returns {string} The URL-safe Base64 encoded string.
		 */
		function urlSafeBase64Encode(str) {
			// 1. Convert string to UTF-8 bytes (Uint8Array)
			const encoder = new TextEncoder();
			const bytes = encoder.encode(str);
			
			// 2. Convert byte array to a "binary string" for btoa()
			// btoa() requires a string where each character is an 8-bit byte.
			let binaryString = '';
			for (let i = 0; i < bytes.length; i++) {
				binaryString += String.fromCharCode(bytes[i]);
			}

			// 3. Standard Base64 Encoding
			let base64 = btoa(binaryString);

			// 4. URL-Safe Conversion
			// Replace non-safe characters and remove padding
			base64 = base64.replace(/\+/g, '-');
			base64 = base64.replace(/\//g, '_');
			base64 = base64.replace(/=/g, ''); // Remove padding

			return base64;
		}
		
		/**
		 * Decodes a URL-safe Base64 string back to the original string.
		 * - Reverses the character replacement: '-' back to '+' and '_' back to '/'.
		 * - Adds padding back if necessary before decoding.
		 * - Handles full UTF-8 support using TextDecoder.
		 * @param {string} base64UrlSafe The URL-safe Base64 encoded string.
		 * @returns {string} The decoded original string.
		 */
		function urlSafeBase64Decode(base64UrlSafe) {
			// 1. Reverse URL-Safe Conversion
			let base64 = base64UrlSafe.replace(/-/g, '+');
			base64 = base64.replace(/_/g, '/');

			// 2. Re-add Padding (Crucial for atob() if removed)
			// Base64 strings must have a length divisible by 4.
			while (base64.length % 4) {
				base64 += '=';
			}

			// 3. Standard Base64 Decoding
			// This returns the "binary string" representation of the bytes
			const binaryString = atob(base64);

			// 4. Convert "binary string" to UTF-8 bytes (Uint8Array)
			const bytes = new Uint8Array(binaryString.length);
			for (let i = 0; i < binaryString.length; i++) {
				bytes[i] = binaryString.charCodeAt(i);
			}
			
			// 5. Convert UTF-8 bytes back to a standard string
			const decoder = new TextDecoder('utf-8');
			return decoder.decode(bytes);
		}
		
        function renderSearchResults(results) {
            searchResultsDiv.innerHTML = results.map(anime => {
                const isLocalMatch = anime.is_local; 
                
                if (isLocalMatch) {
                    const trackedAnime = animeList.find(a => a.id === anime.mal_id);
                    if (trackedAnime) return generateTrackedAnimeCardHtml(trackedAnime, true);
                }
                let b64str = urlSafeBase64Encode(JSON.stringify(anime));
                let buttonHtml = `<button onclick="addAnimeToList('${b64str}')" 
                                    class="w-full py-2 bg-primary-orange text-primary-dark font-bold rounded-lg mt-3 transition duration-200 hover:bg-orange-500 shadow-md shadow-primary-orange/30">
                                      <span data-lucide="plus" class="w-4 h-4 inline-block -mt-0.5"></span> Add to List
                                 </button>`;
                
                return `
                    <div id="search-result-${anime.mal_id}" class="bg-secondary-dark/50 p-4 rounded-xl shadow-xl hover:bg-secondary-dark/70 flex flex-col transition duration-300">
                        <div class="relative">
                            <img src="${anime.images?.webp?.image_url || 'https://placehold.co/100x150/1f2937/9ca3af?text=No+Image'}" 
                                 onerror="this.onerror=null; this.src='https://placehold.co/100x150/1f2937/9ca3af?text=No+Image'"
                                 alt="${anime.title} poster" 
                                 class="w-full h-48 object-cover rounded-lg mb-3 shadow-md border border-primary-orange/20">
                        </div>
                        <h3 class="text-lg font-semibold text-primary-orange truncate" title="${anime.title}">${anime.title}</h3>
                        <p class="text-sm text-muted-text flex-grow">
                            Total Episodes: <span class="font-semibold">${anime.episodes || 'Unknown'}</span> | Status: ${anime.status || 'N/A'}
                        </p>
                        ${buttonHtml}
                    </div>
                `;
            }).join('');
            
            lucide.createIcons();
        }

        // --- Group selection / creation UI ---
        function showGroupSelectionModal(animeId) {
            pendingGroupSelectionAnimeId = animeId;
            loadGroups();
            const modal = document.getElementById('group-selection-modal');
            const list = document.getElementById('group-selection-list');
            if (!modal || !list) return;
            // render groups
            if (!groups || groups.length === 0) {
                list.innerHTML = '<p class="text-sm text-muted-text">No groups yet. Create one below.</p>';
            } else {
                list.innerHTML = groups.map(g => `
                    <div class="flex items-center justify-between p-2 rounded-lg hover:bg-gray-800">
                        <div class="flex items-center">
                            <span class="text-light-text font-medium mr-3">${escapeHtml(g.name)}</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <button class="p-2 bg-primary-orange text-primary-dark rounded-lg text-sm" onclick="assignAnimeToGroup('${g.id}')">Add</button>
                            <button class="p-2 text-muted-text hover:text-red-400" onclick="deleteGroup('${g.id}')"><span data-lucide="trash-2" class="w-4 h-4"></span></button>
                        </div>
                    </div>
                `).join('');
            }

            modal.classList.remove('hidden');
            // stop click outside from closing when interacting inside
            modal.onclick = (e) => { if (e.target === modal) modal.classList.add('hidden'); };
            lucide.createIcons();
        }

        let pendingGroupSelectionAnimeId = null;
    let pendingGroupDeleteId = null;

        function assignAnimeToGroup(groupId) {
            if (!pendingGroupSelectionAnimeId) return;
            const anime = animeList.find(a => a.id === pendingGroupSelectionAnimeId);
            if (!anime) return;
            anime.group = groupId;
            saveList();
            showToast(`Added "${anime.title}" to group "${getGroupName(groupId)}".`);
            // close modal
            const modal = document.getElementById('group-selection-modal');
            if (modal) modal.classList.add('hidden');
            pendingGroupSelectionAnimeId = null;
        }

        function showCreateGroupModal() {
            const modal = document.getElementById('create-group-modal');
            if (!modal) return;
            document.getElementById('create-group-name').value = '';
            modal.classList.remove('hidden');
            modal.onclick = (e) => { if (e.target === modal) modal.classList.add('hidden'); };
        }

        function createGroup() {
            const name = document.getElementById('create-group-name').value.trim();
            if (!name) { showToast('Group name is required.'); return; }
            // enforce unique group names (case-insensitive)
            const lower = name.toLowerCase();
            if (groups.some(g => g.name.toLowerCase() === lower)) { showToast('A group with that name already exists.'); return; }
            const id = generateUUID();
            groups.push({ id, name });
            saveGroups();
            // refresh group modal list
            const list = document.getElementById('group-selection-list');
            if (list) showGroupSelectionModal(pendingGroupSelectionAnimeId);
            // close create modal
            const modal = document.getElementById('create-group-modal');
            if (modal) modal.classList.add('hidden');
        }

        function deleteGroup(groupId) {
            // Show styled confirmation modal for group deletion
            const g = groups.find(x => x.id === groupId);
            if (!g) return;
            pendingGroupDeleteId = groupId;
            const msg = document.getElementById('confirm-delete-group-message');
            const modal = document.getElementById('confirm-delete-group-modal');
            if (msg) msg.textContent = `Delete group "${g.name}"? Anime in this group will not be deleted.`;
            if (modal) modal.classList.remove('hidden');
        }

        function confirmGroupDelete() {
            if (!pendingGroupDeleteId) return;
            const groupId = pendingGroupDeleteId;
            const g = groups.find(x => x.id === groupId);
            if (!g) return;
            groups = groups.filter(x => x.id !== groupId);
            // Remove group association from anime items (but do not delete anime)
            animeList.forEach(a => { if (a.group === groupId) delete a.group; });
            saveGroups();
            saveList();
            pendingGroupDeleteId = null;
            const modal = document.getElementById('confirm-delete-group-modal');
            if (modal) modal.classList.add('hidden');
            // refresh modal if open
            const selModal = document.getElementById('group-selection-modal');
            if (selModal && !selModal.classList.contains('hidden')) showGroupSelectionModal(null);
        }

        function cancelGroupDelete() {
            pendingGroupDeleteId = null;
            const modal = document.getElementById('confirm-delete-group-modal');
            if (modal) modal.classList.add('hidden');
        }

        // Utility to get group name by id
        function getGroupName(id) {
            const g = groups.find(x => x.id === id);
            return g ? g.name : null;
        }

        // Simple escape for insertion into HTML templates
        function escapeHtml(str) {
            if (!str) return '';
            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        function renderTrackingList() {
            if (animeList.length === 0) {
                trackingListDiv.innerHTML = '';
                emptyListMessage.classList.remove('hidden');
                return;
            }
            
            emptyListMessage.classList.add('hidden');

            let sortedList = [...animeList]; 
            
            if (currentSortKey === 'title_asc') sortedList.sort((a, b) => a.title.localeCompare(b.title));
            else if (currentSortKey === 'title_desc') sortedList.sort((a, b) => b.title.localeCompare(a.title));
            else if (currentSortKey === 'timestamp_desc') sortedList.sort((a, b) => b.timestamp - a.timestamp); 
            else if (currentSortKey === 'timestamp_asc') sortedList.sort((a, b) => a.timestamp - b.timestamp);
            
            let filteredList = sortedList.filter(anime => activeFilters[anime.category]);

            // Apply group filter if set
            if (activeGroupFilter) {
                filteredList = filteredList.filter(a => a.group === activeGroupFilter);
            }

            if (filteredList.length === 0) {
                 trackingListDiv.innerHTML = `<p class="text-center text-muted-text mt-4 col-span-full text-xl">
                     No anime visible under the current filters. Click the filter buttons above to change visibility.
                 </p>`;
                 return;
            }

            trackingListDiv.innerHTML = filteredList.map(anime => {
                return generateTrackedAnimeCardHtml(anime, false);
            }).join('');
            
            lucide.createIcons();
        }

        // --- Card menu helpers ---
        function closeAllCardMenus() {
            document.querySelectorAll('.card-action-menu').forEach(m => {
                if (m.classList.contains('hidden')) return;
                // remove visible to play hide transition, then add hidden after transition
                m.classList.remove('visible');
                setTimeout(() => {
                    m.classList.add('hidden');
                    // reset any inline positioning adjustments
                    m.style.left = '';
                    m.style.right = '';
                }, 220);
            });
        }

        function toggleCardMenu(id, event) {
            if (event && event.stopPropagation) event.stopPropagation();
            const menu = document.getElementById(`card-menu-${id}`);
            if (!menu) return;
            const willShow = menu.classList.contains('hidden');
            // Close any other open menus (with animation)
            closeAllCardMenus();
            if (willShow) {
                // Show then trigger the visible state for animation
                // reset any previous inline positions
                menu.style.left = '';
                menu.style.right = '';
                menu.classList.remove('hidden');
                // allow the browser to apply display before adding visible and measuring
                requestAnimationFrame(() => {
                    menu.classList.add('visible');
                    // After showing, check for horizontal overflow and flip if necessary
                    const rect = menu.getBoundingClientRect();
                    const padding = 8; // minimal padding from viewport edge
                    if (rect.right > window.innerWidth - padding) {
                        // flip menu to align to the left of the parent
                        menu.style.right = 'auto';
                        menu.style.left = '0';
                    } else {
                        // normal positioning
                        menu.style.left = '';
                        menu.style.right = '0';
                    }
                });
            }
        }

        function deleteAnimeFromCard(id) {
            // Close menus first for visual clarity
            closeAllCardMenus();
            // Use existing removal function which also saves state
            removeAnimeFromList(id);
        }

        // Close menus when clicking outside
        document.addEventListener('click', (e) => {
            closeAllCardMenus();
        });

        // --- Delete confirmation dialog flow ---
        let pendingDeleteId = null;

        function showDeleteConfirm(id) {
            closeAllCardMenus();
            const menu = document.getElementById(`card-menu-${id}`);
            const title = (menu && menu.dataset && menu.dataset.title) ? menu.dataset.title : 'this anime';
            pendingDeleteId = id;
            const modal = document.getElementById('confirm-delete-modal');
            const msg = document.getElementById('confirm-delete-message');
            if (msg) msg.textContent = `Do you want to remove "${title}"?`;
            if (modal) modal.classList.remove('hidden');
        }

        function confirmDelete() {
            if (pendingDeleteId !== null) {
                removeAnimeFromList(pendingDeleteId);
            }
            pendingDeleteId = null;
            const modal = document.getElementById('confirm-delete-modal');
            if (modal) modal.classList.add('hidden');
        }

        function cancelDelete() {
            pendingDeleteId = null;
            const modal = document.getElementById('confirm-delete-modal');
            if (modal) modal.classList.add('hidden');
        }

        // --- Initialization ---

        window.onload = () => {
            loadGroups();
            initializeUser(); 
        };

        // Expose global functions for HTML interaction
        window.debouncedSearch = debouncedSearch;
        window.addAnimeToList = addAnimeToList;
        window.removeAnimeFromList = removeAnimeFromList;
        window.updateEpisodeCount = updateEpisodeCount;
        window.handleEpisodeInputChange = handleEpisodeInputChange;
        window.updateAnimeCategory = updateAnimeCategory;
        window.sortAndRenderList = sortAndRenderList; 
        window.toggleFilter = toggleFilter; 
        window.clearSearch = clearSearch;
        window.toggleClearButton = toggleClearButton;
        window.startLongPress = startLongPress;
        window.endLongPress = endLongPress;
        window.handleSearch = handleSearch;
        
        // Expose new user management functions
        window.showUserSelectModal = showUserSelectModal;
        window.setActiveUser = setActiveUser;
        window.addNewUser = addNewUser;
        window.deleteUser = deleteUser;
        window.showRegisterModal = showRegisterModal;
        window.handleNewUserRegistration = handleNewUserRegistration;
        window.handleUserSwitchAttempt = handleUserSwitchAttempt;
        window.loginUser = loginUser;
        window.hideModal = hideModal; // Expose hideModal
        
        // Expose NEW Data Transfer Functions
        window.exportUserData = exportUserData;
        window.handleImportFile = handleImportFile;
        window.showDataTransferModal = showDataTransferModal;
        
    </script>
</body>
</html>